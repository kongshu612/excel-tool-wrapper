{"version":3,"file":"excel-tool.js","mappings":"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","sources":["webpack://@kongshu612/excel-tool/webpack/universalModuleDefinition","webpack://@kongshu612/excel-tool/./lib/excel-helper.ts","webpack://@kongshu612/excel-tool/./lib/excel-import-export.ts","webpack://@kongshu612/excel-tool/./lib/index.ts","webpack://@kongshu612/excel-tool/external commonjs \"exceljs\"","webpack://@kongshu612/excel-tool/external commonjs \"file-saver\"","webpack://@kongshu612/excel-tool/external commonjs \"lodash\"","webpack://@kongshu612/excel-tool/external commonjs \"luxon\"","webpack://@kongshu612/excel-tool/webpack/bootstrap","webpack://@kongshu612/excel-tool/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, () => {\nreturn ","import { CellDataType, ICellMetaData, ITransferWithDataType, ISheetMetaDataWithRows } from \"./excel-model\";\r\nimport { DateTime } from \"luxon\";\r\n\r\n\r\nlet fakeId: number = -1;\r\n\r\nexport const yesNoOptions = [{ label: 'Yes', value: true }, { label: 'No', value: false }];\r\n\r\nfunction getFakeId() {\r\n  return fakeId--;\r\n}\r\n\r\nexport function isNameEquals(original: string, other: string) {\r\n  return original?.toLocaleLowerCase?.()?.trim() == other?.toLocaleLowerCase?.()?.trim();\r\n}\r\n\r\nexport function getLookupCodeMapping(\r\n  options: { label: string; value: any }[],\r\n  toExcelDefault = null,\r\n  dataType: CellDataType = 'number',\r\n): ITransferWithDataType {\r\n  return <ITransferWithDataType>{\r\n    toExcel: (val?: any) => options.find((it) => it.value === val)?.label ?? toExcelDefault ?? (typeof (val) === 'string' ? val : null),\r\n    fromExcel: (val: string) =>\r\n      options.find((it) => isNameEquals(it.label, val))?.value || null,\r\n    options,\r\n    dataType,\r\n  };\r\n}\r\n\r\nexport function getLookupCodeArrayMapping(\r\n  options: { label: string; value: any }[],\r\n  toExcelDefault = null,\r\n  supportCreating = false,\r\n  dataType: CellDataType = 'numbers',\r\n): ITransferWithDataType {\r\n  return <ITransferWithDataType>{\r\n    toExcel: (val?: number[]) => {\r\n      if (val?.length ?? 0 > 0) {\r\n        return val!.map(id => {\r\n          const label = options.find(opt => opt.value === id)?.label;\r\n          return !label?.length ? toExcelDefault : label;\r\n        })\r\n          .filter(it => it != null)\r\n          .join(',');\r\n      } else {\r\n        return '';\r\n      }\r\n    },\r\n    fromExcel: (val: string) => {\r\n      if (!val?.length) { return []; }\r\n      const valArray = val.split(',').filter(it => it?.trim()?.length > 0);\r\n      return valArray.map(it => {\r\n        const optId = options.find(opt => isNameEquals(opt.label, it))?.value;\r\n        if (optId == null && supportCreating) {\r\n          const fakeItem = { label: it, value: getFakeId() };\r\n          options.push(fakeItem);\r\n          return fakeItem.value;\r\n        } else {\r\n          return optId;\r\n        }\r\n      }).filter(it => !!it);\r\n    },\r\n    options,\r\n    showOptions: false,\r\n    dataType,\r\n  };\r\n}\r\n\r\nexport function getNumberMapping(): ITransferWithDataType {\r\n  return {\r\n    toExcel: (val?: any) => {\r\n      if (val == null) {\r\n        return null;\r\n      } else {\r\n        return Number.isNaN(val) ? null : val;\r\n      }\r\n    },\r\n    fromExcel: (val: any) => {\r\n      if (val == null) return null;\r\n      if (typeof val === 'number' || typeof val === 'bigint') {\r\n        return val;\r\n      } else {\r\n        let num = Number.parseFloat(val);\r\n        return Number.isNaN(num) ? null : num;\r\n      }\r\n    },\r\n    dataType: 'number',\r\n  };\r\n}\r\n\r\nexport function getStringMapping(): ITransferWithDataType {\r\n  return {\r\n    toExcel: (val: any) => `${val || ''}`,\r\n    fromExcel: (val: any) => `${val || ''}`.trim(),\r\n    dataType: 'string',\r\n  };\r\n}\r\n\r\nfunction getDefaultNumbersMapping(): ITransferWithDataType {\r\n  return <ITransferWithDataType>{\r\n    fromExcel: (val: string) => val?.length > 0 ? val.split(';') : [],\r\n    toExcel: (val: any[]) => val.length > 0 ? val.join(';') : '',\r\n    dataType: 'numbers',\r\n  }\r\n}\r\n\r\nconst yesConsts = ['yes', 'ok', 'true', 'allow', 'visible', 'y'];\r\nconst noConsts = ['no', 'false', 'forbidden', 'disable', 'hide', 'invisible', 'n'];\r\nconst nullConsts = ['mute'];\r\n\r\nfunction isYesNoWord(val: string) {\r\n  if (!val?.length) {\r\n    return false;\r\n  }\r\n  return yesConsts.concat(noConsts).concat(nullConsts).includes(val.toLocaleLowerCase()?.trim());\r\n}\r\n\r\nexport function getYesNoMapping(showBlank = false): ITransferWithDataType {\r\n  return <ITransferWithDataType>{\r\n    toExcel: (val?: boolean) =>\r\n      val != null ? (val === true ? 'Yes' : 'No') : (showBlank ? '(blank)' : null),\r\n    fromExcel: (val: boolean | string) => {\r\n      if (val === true || val === false) return val;\r\n      if (val == null) return null;\r\n      if (typeof (val) != 'string') return null;\r\n      if (yesConsts.includes(val.toLocaleLowerCase()?.trim())) {\r\n        return true;\r\n      }\r\n      if (noConsts.includes(val.toLocaleLowerCase()?.trim())\r\n      ) {\r\n        return false;\r\n      }\r\n      return null;\r\n    },\r\n    options: yesNoOptions,\r\n    dataType: 'boolean',\r\n  };\r\n}\r\n\r\nexport function getBooleanMapping(): ITransferWithDataType {\r\n  return <ITransferWithDataType>{\r\n    toExcel: (val?: boolean) =>\r\n      val != null ? (val === true ? 'TRUE' : 'FALSE') : null,\r\n    fromExcel: (val: boolean | string) => {\r\n      if (val === true || val === false) return val;\r\n      if (typeof (val) != 'string' || !val?.length || ['na', 'null'].includes(val.toLocaleLowerCase())) {\r\n        return null;\r\n      }\r\n      if (\r\n        ['yes', 'ok', 'true', 'allow', 'visible'].includes(\r\n          val.toLocaleLowerCase()?.trim()\r\n        )\r\n      ) {\r\n        return true;\r\n      }\r\n      if (\r\n        [\r\n          'no',\r\n          'false',\r\n          'forbidden',\r\n          'disable',\r\n          'mute',\r\n          'hide',\r\n          'invisible',\r\n        ].includes(val.toLocaleLowerCase()?.trim())\r\n      ) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    options: yesNoOptions,\r\n    dataType: 'boolean',\r\n  };\r\n}\r\n\r\nexport function getDateMapping(): ITransferWithDataType {\r\n  return {\r\n    toExcel: (val: string) => {\r\n      return val;\r\n    },\r\n    fromExcel: (val: number | string | Date) => {\r\n      try {\r\n        if (!val) { return null; }\r\n        //https://github.com/SheetJS/sheetjs/issues/1223\r\n        if (typeof val === 'number') {\r\n          const date = DateTime.fromMillis(Math.round((val - 25569) * 86400 * 1000));\r\n          if (date.year > 3000 || date.year < 1000) {\r\n            return null;\r\n          }\r\n          return date\r\n            .toFormat('yyyy-MM-dd');\r\n        }\r\n        else if (Object.prototype.toString.call(val) === '[object Date]') {\r\n          const date = DateTime.fromJSDate(val as Date, { zone: 'utc' });\r\n          if (date.year > 3000 || date.year < 1000) {\r\n            return null;\r\n          }\r\n          return date\r\n            .toFormat('yyyy-MM-dd')\r\n        }\r\n        else if (typeof val === 'string') {\r\n          return parseDateFromString(val);\r\n        }\r\n        else {\r\n          return null;\r\n        }\r\n      } catch (ex) {\r\n        return null;\r\n      }\r\n    },\r\n    dataType: 'dateTime',\r\n  };\r\n}\r\n\r\nfunction parseDateFromString(val: string) {\r\n  let formats = ['yyyy-MM-dd', 'MM-dd-yyyy', 'yyyy-M-dd', 'yyyy.MM.dd', 'MM.dd.yyyy'];\r\n  for (let format of formats) {\r\n    let date = DateTime.fromFormat(val, format);\r\n    if (date && date.toFormat('yyyy-MM-dd') !== 'Invalid DateTime') {\r\n      return date.toFormat('yyyy-MM-dd');\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function getDirectMapping(dataType: CellDataType = 'string'): ITransferWithDataType {\r\n  return {\r\n    toExcel: (val: any) => val,\r\n    fromExcel: (val: any) => val,\r\n    dataType,\r\n  };\r\n}\r\n\r\nexport function getDefaultMappingByType(dataType: CellDataType): ITransferWithDataType {\r\n  switch (dataType) {\r\n    case 'boolean': return getYesNoMapping();\r\n    case 'dateTime': return getDateMapping();\r\n    case 'number': return getNumberMapping();\r\n    case 'string': return getStringMapping();\r\n    case 'numbers': return getDefaultNumbersMapping();\r\n    default: return getDirectMapping();\r\n  }\r\n}\r\n\r\nfunction getDataTypeByValue(val: any): CellDataType {\r\n  if (typeof val === 'bigint' || typeof val === 'number') {\r\n    return 'number';\r\n  } else if (typeof val === 'boolean') {\r\n    return 'boolean';\r\n  } else if (val != null && Object.prototype.toString.call(val) === '[object Date]') {\r\n    return 'dateTime';\r\n    // } else if (val != null && isYesNoWord(val)) {\r\n    //   return 'boolean';\r\n  } else if (Array.isArray(val)) {\r\n    return 'numbers';\r\n  }\r\n  else {\r\n    return 'string';\r\n  }\r\n}\r\n\r\nexport function getDefaultMappingByValueType(val: any): ITransferWithDataType {\r\n  return getDefaultMapping(getDataTypeByValue(val));\r\n}\r\n\r\nexport function getDefaultMapping(dataType?: CellDataType, val?: any): ITransferWithDataType {\r\n  if (dataType != null) {\r\n    return getDefaultMappingByType(dataType);\r\n  } else {\r\n    return getDefaultMappingByValueType(val);\r\n  }\r\n}\r\n\r\nexport function constructSheetColumnMetasFromObject(data: any): Pick<ISheetMetaDataWithRows, 'columns'> {\r\n  let columns: ICellMetaData[] = [];\r\n  if (data == null) {\r\n    throw new Error('data can not be null');\r\n  }\r\n  Object.entries(data).forEach(([key, value]) => {\r\n    let cell: ICellMetaData = {\r\n      fieldName: key,\r\n      header: key,\r\n      ...getDefaultMappingByValueType(value)\r\n    };\r\n    columns.push(cell);\r\n  })\r\n  return { columns };\r\n}\r\n\r\n\r\n","import {\r\n  ICellMetaData,\r\n  ISheetMetaData,\r\n  IXlsxMetaData,\r\n  IXlsxData,\r\n  ISheetMetaDataWithRows,\r\n} from './excel-model';\r\n\r\nimport { CellValue, Workbook, Worksheet } from 'exceljs';\r\nimport { saveAs } from 'file-saver';\r\nimport _ from 'lodash';\r\nimport { isNameEquals, getDefaultMappingByValueType, getDefaultMapping, constructSheetColumnMetasFromObject, getYesNoMapping, yesNoOptions } from './excel-helper';\r\n\r\n\r\n\r\n// num is 0 based\r\nfunction convertToXlsxColumnIndex(num: number) {\r\n  let result = '';\r\n  let [mod, remaining] = [0, num];\r\n  while (remaining >= 0) {\r\n    [mod, remaining] = [remaining % 26, Math.floor(remaining / 26) - 1];\r\n    let c = String.fromCharCode('A'.charCodeAt(0) + mod);\r\n    result = `${c}${result}`;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction findSheetMetaByName(index: number, sheetName: string, fileMetas: ISheetMetaData[]) {\r\n  // index take high priority\r\n  if (index <= fileMetas.length) {\r\n    const meta = fileMetas[index - 1];\r\n    if (isNameEquals(meta.sheetName, sheetName)) {\r\n      return meta;\r\n    }\r\n  }\r\n  // by name as second priority\r\n  const meta = fileMetas.find(it => isNameEquals(it.sheetName, sheetName));\r\n  return meta ?? fileMetas?.[index - 1];\r\n}\r\n\r\nfunction parseSheets(wb: Workbook, fileMetas?: ISheetMetaData[]): IXlsxData {\r\n  let result: IXlsxData = {};\r\n  wb.eachSheet((ws, index) => {\r\n    // index in excel is 1 based\r\n    let sheetMeta: ISheetMetaData | undefined;\r\n    if (!fileMetas?.length || (sheetMeta = findSheetMetaByName(index, ws.name, fileMetas)) == null) {\r\n      Object.assign(result, { [ws.name]: parseSheet(ws) });\r\n      return;\r\n    }\r\n    const { sheetName, columns, showHeader = true, runningInStrictMode = true } = sheetMeta;\r\n    Object.assign(result, { [sheetName]: parseSheet(ws, columns, showHeader, runningInStrictMode) });\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction parseSheetsInCompatiableMode(wb: Workbook): IXlsxData {\r\n  let result: IXlsxData = {};\r\n  wb.eachSheet((ws, index) => {\r\n    Object.assign(result, parseSheetInCompatiableMode(ws))\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction parseSheetInCompatiableMode(ws: Worksheet) {\r\n  let rowDatas: any[] = [];\r\n  let maxColumn = 1;\r\n  let { name } = ws;\r\n  let columns: string[] = [];\r\n  let rowReadEnded: boolean = false;\r\n  ws.eachRow((row, index) => {\r\n    if (index === 1) {\r\n      let colIndex = 1;\r\n      let header: string | null = null;\r\n      do {\r\n        header = row.getCell(colIndex).value as string;\r\n        if (header?.length > 0) {\r\n          columns.push(header.trim());\r\n        }\r\n        maxColumn = colIndex;\r\n        colIndex++;\r\n      } while (header?.length > 0);\r\n      return;\r\n    }\r\n    if (rowReadEnded || !Array.isArray(row.values)) {\r\n      return;\r\n    }\r\n    if (row.values[1] === BREAK_LINE) {\r\n      rowReadEnded = true;\r\n      return;\r\n    }\r\n    let rowData: any = {};\r\n    for (let i = 1; i < maxColumn; i++) {\r\n      let originalValue = row.values[i];\r\n      if (typeof originalValue === 'object' && originalValue != null && 'text' in originalValue) {\r\n        originalValue = originalValue['text'];\r\n      }\r\n      const key = columns[i - 1];\r\n      const fromExcelValue = getDefaultMappingByValueType(originalValue).fromExcel(originalValue);\r\n      // incase we have duplicate rows, the one with value will overwrite the one without value\r\n      if (rowData[key] == null || (typeof rowData[key] === 'string' && !rowData[key].length)) {\r\n        rowData[key] = fromExcelValue;\r\n      }\r\n    }\r\n    if (isObjectNotEmpty(rowData)) {\r\n      rowDatas.push(rowData);\r\n    }\r\n  });\r\n  return { [name]: rowDatas };\r\n}\r\n\r\nfunction isObjectNotEmpty(obj: any) {\r\n  return Object.values(obj).filter(it => !!it).length > 0;\r\n}\r\n\r\nfunction parseSheet(ws: Worksheet, columns?: ICellMetaData[], includeHeader: boolean = true, runningInStrictMode: boolean = true) {\r\n  let result: any[] = [];\r\n  let rowReadEnded: boolean = false;\r\n  let columnMapping: any = {}; // this value is used in Compatiable Parse Mode\r\n  let maxColumn = 1; // this value is used in Compatiable Parse Mode\r\n  ws.eachRow((row, i) => {\r\n    if (rowReadEnded || !Array.isArray(row.values)) {\r\n      return;\r\n    }\r\n    if (row.values[1] === BREAK_LINE) {\r\n      rowReadEnded = true;\r\n      return;\r\n    }\r\n    // raw Mapping Scenario, we just mapping raw value from excel to memory, format and\r\n    // transformation of the value is not included.\r\n    // for raw Mapping, we will include headers\r\n    // for row in excel, the index start of one, so we need to skip the zero item.\r\n    if (!columns?.length) {\r\n      result.push((row.values as CellValue[]).slice(1).map(it => {\r\n        if (typeof it === 'object' && it != null && 'text' in it) {\r\n          return it['text'];\r\n        } else {\r\n          return it;\r\n        }\r\n      }));\r\n      return;\r\n    }\r\n    // index of excel start from one.\r\n    // this is branch which will do the format and transfer, the logic is from the fieldmeta\r\n    if (i === 1) {\r\n      if (includeHeader == true && runningInStrictMode == true) {\r\n        for (let colIndex = 0; colIndex < columns.length; colIndex++) {\r\n          if (!isNameEquals(row.getCell(colIndex + 1).value as string, columns[colIndex].header as string)) {\r\n            throw new Error(`header with name \"${row.getCell(colIndex + 1).value}\" is different with what from meta \"${columns[colIndex].header}\"`);\r\n          }\r\n        }\r\n      } else if (!runningInStrictMode) {\r\n        if (includeHeader == false) {\r\n          throw new Error(`we don't support mapping without header in Non Strict Mode. It is easily to make a miss-mapping without header.`);\r\n        }\r\n        let colIndex = 1, header: string | null = null;\r\n        do {\r\n          header = row.getCell(colIndex).value as string;\r\n          if (header?.length > 0) {\r\n            const column = columns.find(it => isNameEquals(it.header!, header!));\r\n            if (column != null) {\r\n              columnMapping[colIndex] = column;\r\n            } else {\r\n              console.warn(`${header} Not Founded, we will ignore this column`);\r\n            }\r\n          }\r\n          maxColumn = colIndex;\r\n          colIndex++;\r\n        } while (header?.length > 0);\r\n      }\r\n      if (includeHeader) {\r\n        return;\r\n      }\r\n    }\r\n    let rowData: any = {};\r\n    if (runningInStrictMode) {\r\n      columns.forEach((col, index) => {\r\n        const { fieldName, fromExcel, dataType } = col;\r\n        let originalValue = (row.values as CellValue[])[index + 1];\r\n        if (typeof originalValue === 'object' && originalValue != null && 'text' in originalValue) {\r\n          originalValue = originalValue['text'];\r\n        }\r\n        rowData[fieldName] = (fromExcel ?? getDefaultMapping(dataType, originalValue).fromExcel)(originalValue);\r\n      });\r\n    } else {\r\n      for (let index = 1; index < maxColumn; index++) {\r\n        const col = columnMapping[index];\r\n        if (col != null) {\r\n          const { fieldName, fromexcel, dataType } = col;\r\n          let originalValue = row.values[index];\r\n          if (typeof originalValue === 'object' && originalValue != null && 'text' in originalValue) {\r\n            originalValue = originalValue['text'];\r\n          }\r\n          rowData[fieldName] = (fromexcel ?? getDefaultMapping(dataType, originalValue).fromExcel)(originalValue);\r\n        }\r\n      }\r\n    }\r\n    if (isObjectNotEmpty(rowData)) {\r\n      result.push(rowData);\r\n    }\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction populateSheet(sheetMeta: ISheetMetaDataWithRows, ws: Worksheet) {\r\n  let result: any[][] = [];\r\n  const { columns, rows = [], showHeader = true } = sheetMeta;\r\n  if (showHeader) {\r\n    result.push(columns.map(it => it.header || it.fieldName));\r\n    ws.columns = columns.map(it => ({ header: it.header || it.fieldName }));\r\n  }\r\n  putBreakline(ws);\r\n  // set the cell headers and apply validations if any\r\n  columns.forEach((col, index) => {\r\n    if (col.required) {\r\n      const cell = ws.getCell(1, index + 1);\r\n      cell.font = {\r\n        color: { argb: 'ffff0000' },\r\n        bold: true,\r\n      }\r\n    }\r\n    if (!!col.dataValidations || col.dataType === 'boolean') {\r\n      const { options, affectedRowCount = 9999 } = col.dataValidations ?? { options: yesNoOptions };\r\n      const optionsLabels = (options as any[]).map(it => it.label);\r\n      const formulae = getDataValidationRange(ws, optionsLabels, index);\r\n      for (let r = showHeader ? 2 : 1; r < affectedRowCount; r++) {\r\n        ws.getCell(r, index + 1).dataValidation = {\r\n          type: 'list',\r\n          allowBlank: true,\r\n          formulae: [formulae],\r\n          showErrorMessage: true,\r\n        };;\r\n      }\r\n    }\r\n  });\r\n  // populate the row data if any\r\n  if (rows.length > 0) {\r\n    for (let i = 0; i < rows.length; i++) {\r\n      const row = rows[i];\r\n      const rowIndex = showHeader ? i + 2 : i + 1;\r\n      let rowValue: any[] = [];\r\n      columns.forEach((col, index) => {\r\n        const { fieldName, toExcel, dataType } = col;\r\n        let val = _.get(row, fieldName);\r\n        val = toExcel ? toExcel(val) : getDefaultMapping(dataType, val).toExcel(val);\r\n        rowValue.push(val);\r\n        ws.getCell(rowIndex, index + 1).value = val;\r\n      });\r\n      result.push(rowValue);\r\n    }\r\n  }\r\n  let columnWidth: number[] = [];\r\n  columns.forEach((col, index) => {\r\n    const { wch } = col;\r\n    if (wch) {\r\n      columnWidth[index] = wch;\r\n    }\r\n  })\r\n  fitToColumn(result, ws, columnWidth);\r\n}\r\n\r\nconst LINKROW_NUMBER: number = 100000;\r\nconst BREAK_LINE: string = '__BREAKLINE__';\r\n\r\n// we put a break line to seperate content and data validation\r\nfunction putBreakline(ws: Worksheet) {\r\n  const cell = ws.getCell(LINKROW_NUMBER - 1, 1);\r\n  cell.value = BREAK_LINE;\r\n  cell.font = {\r\n    color: { argb: 'ffffffff' },\r\n  }\r\n}\r\n// column number is 0 based\r\nfunction getDataValidationRange(ws: Worksheet, options: string[], column: number) {\r\n  const columnIndex = convertToXlsxColumnIndex(column);\r\n  for (let i = 0; i < options.length; i++) {\r\n    let rowNumber = LINKROW_NUMBER + i;\r\n    const cell = ws.getCell(rowNumber, column + 1);\r\n    cell.font = {\r\n      color: { argb: 'ffffffff' },\r\n    }\r\n    cell.value = options[i];\r\n  }\r\n  return `$${columnIndex}$${LINKROW_NUMBER}:$${columnIndex}$${LINKROW_NUMBER + options.length - 1}`;\r\n}\r\n\r\n\r\nfunction fitToColumn(arrayOfArray: any[][], ws: Worksheet, columnWidth: any[] = []) {\r\n  // get maximum character of each column\r\n  if (!arrayOfArray?.length) {\r\n    return;\r\n  }\r\n  return arrayOfArray[0].forEach((col, i) => {\r\n    const width = columnWidth[i];\r\n    if (width != null) {\r\n      ws.getColumn(i + 1).width = width;\r\n      return;\r\n    }\r\n    const maxlen = Math.max(\r\n      ...arrayOfArray\r\n        .map((a2) => a2[i]?.toString()?.length)\r\n        .filter((it) => it > 0)\r\n    ) + 3;\r\n    ws.getColumn(i + 1).width = maxlen > 15 ? maxlen : 15;\r\n  })\r\n}\r\n\r\nfunction mergeObject(source: any[]) {\r\n  if (!source?.length) {\r\n    throw new Error('input parameter can not be empty');\r\n  }\r\n  let result = Object.assign({}, source[0]);\r\n  for (let i = 1; i < source.length; i++) {\r\n    for (let [key, value] of Object.entries(source[i])) {\r\n      if (value !== null && value !== undefined) {\r\n        result[key] = value;\r\n      }\r\n    };\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction removeEmptyFieldFromData(data: any, ignoreWarning: boolean) {\r\n  let result: any = {};\r\n  for (let [key, value] of Object.entries(data)) {\r\n    if (value == null) {\r\n      if (!ignoreWarning) {\r\n        throw new Error(`${key} in parameter is empty, you must provide a value, or set ignoreWarning as true`);\r\n      }\r\n      console.warn(`${key} in parameter is empty, we will skip mapping for this column`)\r\n      continue;\r\n    }\r\n    result[key] = value;\r\n  }\r\n  return result;\r\n}\r\n\r\nconst isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\");\r\n\r\nasync function saveToFile(workbook: Workbook, fileName: string) {\r\n  if (isBrowser()) {\r\n    const buffer = await workbook.xlsx.writeBuffer();\r\n    const fileType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\r\n    const fileExtension = '.xlsx';\r\n    const exportFileName = fileName.indexOf('.xlsx') >= 0 ? fileName : `${fileName}${fileExtension}`;\r\n\r\n    const blob = new Blob([buffer], { type: fileType });\r\n    saveAs(blob, exportFileName);\r\n  } else {\r\n    await workbook.xlsx.writeFile(fileName);\r\n  }\r\n}\r\n\r\n\r\nasync function exportObjectsInSingleSheet(data: any[], fileName: string, sheetName: string = 'Sheet', showHeader: boolean = true) {\r\n  const mergedObject = mergeObject(data);\r\n  const { columns } = constructSheetColumnMetasFromObject(mergedObject);\r\n  const sheet: ISheetMetaDataWithRows = { columns, sheetName, showHeader, rows: data };\r\n  await exportToExcel({ fileName, sheets: [sheet] });\r\n}\r\n\r\nasync function exportObjectsInMultiSheet(data: { [key in string]: any[] }, fileName: string, showHeader: boolean = true) {\r\n  const sheets: ISheetMetaDataWithRows[] = Object.entries(data)\r\n    .filter(([key, value]) => Array.isArray(value) && value.length > 0)\r\n    .map(([key, value]) => {\r\n      const mergedObject = mergeObject(value);\r\n      const { columns } = constructSheetColumnMetasFromObject(mergedObject);\r\n      const sheet: ISheetMetaDataWithRows = { columns, sheetName: key, showHeader, rows: value };\r\n      return sheet;\r\n    });\r\n  await exportToExcel({ fileName, sheets });\r\n}\r\n\r\n\r\nasync function exportToExcel(fileMeta: IXlsxMetaData) {\r\n  const { fileName, sheets } = fileMeta;\r\n  const wb = new Workbook();\r\n  for (let sheetMeta of sheets) {\r\n    const { sheetName } = sheetMeta;\r\n    const ws = wb.addWorksheet(sheetName);\r\n    populateSheet(sheetMeta, ws);\r\n  }\r\n  await saveToFile(wb, fileName);\r\n}\r\n\r\n\r\nasync function parseObjectsFromExcel(file: File | string, data: any, ignoreWarning: boolean = false) {\r\n  const consolidatedObject = removeEmptyFieldFromData(data, ignoreWarning);\r\n  const { columns } = constructSheetColumnMetasFromObject(consolidatedObject);\r\n  const sheet: ISheetMetaDataWithRows = { columns, sheetName: '', showHeader: true, runningInStrictMode: false };\r\n  return await importObjects(file, [sheet]);\r\n}\r\n\r\nexport async function exportObjects(data: any[], fileName: string, showHeader: boolean, sheetName: string): Promise<void>;\r\nexport async function exportObjects(data: { [key in string]: any[] }, fileName: string, showHeader: boolean): Promise<void>;\r\nexport async function exportObjects(fileMeta: IXlsxMetaData): Promise<void>;\r\nexport async function exportObjects(data: { [key in string]: any[] } | any[] | IXlsxMetaData, fileName?: string, showHeader: boolean = true, sheetName: string = 'Sheet'): Promise<void> {\r\n  if (Array.isArray(data)) {\r\n    await exportObjectsInSingleSheet(data, fileName!, sheetName, showHeader);\r\n  } else if ('fileName' in data && 'sheets' in data && Array.isArray(data.sheets) && data.sheets.length > 0 && fileName == null) {\r\n    await exportToExcel((data as unknown) as IXlsxMetaData);\r\n  }\r\n  else {\r\n    await exportObjectsInMultiSheet(data as any, fileName!, showHeader);\r\n  }\r\n}\r\n\r\nexport async function importObjects(file: File | string): Promise<IXlsxData | null>;\r\nexport async function importObjects(file: File | string, fileMeta: ISheetMetaData[]): Promise<IXlsxData | null>;\r\nexport async function importObjects(file: File | string, data: { [key in string]: any }, compatiableMode: boolean): Promise<IXlsxData | null>\r\nexport async function importObjects(file: File | string, fileMeta?: ISheetMetaData[] | { [key in string]: any }, compatiableMode?: boolean): Promise<IXlsxData | null> {\r\n  if (fileMeta != null && !Array.isArray(fileMeta) && compatiableMode !== undefined) {\r\n    return await parseObjectsFromExcel(file, fileMeta, compatiableMode);\r\n  }\r\n  if (file == null) {\r\n    return Promise.resolve(null);\r\n  } else if (typeof file === 'string') {\r\n    return new Promise<IXlsxData | null>(async (resolve, reject) => {\r\n      try {\r\n        const wb = new Workbook();\r\n        const workbook = await wb.xlsx.readFile(file);\r\n        resolve(fileMeta != null && Array.isArray(fileMeta) && fileMeta.length > 0 ? parseSheets(workbook, fileMeta) : parseSheetsInCompatiableMode(workbook));\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  }\r\n  else {\r\n    return new Promise<IXlsxData | null>((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = async (e) => {\r\n        try {\r\n          const wb = new Workbook();\r\n          const workbook = await wb.xlsx.load(reader.result as any);\r\n          resolve(fileMeta != null && Array.isArray(fileMeta) && fileMeta.length > 0 ? parseSheets(workbook, fileMeta) : parseSheetsInCompatiableMode(workbook));\r\n        } catch (err) {\r\n          reject(err);\r\n        }\r\n      };\r\n      reader.readAsArrayBuffer(file);\r\n    });\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","export * from './excel-model';\r\nexport * from './excel-import-export';\r\nexport * from './excel-helper';\r\n","module.exports = require(\"exceljs\");","module.exports = require(\"file-saver\");","module.exports = require(\"lodash\");","module.exports = require(\"luxon\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(620);\n"],"names":["root","factory","exports","module","define","amd","a","i","this","fakeId","isNameEquals","original","other","toLocaleLowerCase","trim","getNumberMapping","toExcel","val","Number","isNaN","fromExcel","num","parseFloat","dataType","yesNoOptions","label","value","options","toExcelDefault","find","it","supportCreating","length","map","id","opt","filter","join","split","optId","fakeItem","push","showOptions","yesConsts","noConsts","getYesNoMapping","showBlank","includes","getDateMapping","date","DateTime","fromMillis","Math","round","year","toFormat","Object","prototype","toString","call","fromJSDate","zone","format","fromFormat","parseDateFromString","ex","getDirectMapping","getDefaultMappingByType","getDefaultMappingByValueType","getDefaultMapping","Array","isArray","getDataTypeByValue","data","columns","Error","entries","forEach","key","cell","fieldName","header","parseSheets","wb","fileMetas","result","eachSheet","ws","index","sheetMeta","sheetName","meta","findSheetMetaByName","name","showHeader","runningInStrictMode","assign","parseSheet","parseSheetsInCompatiableMode","rowDatas","maxColumn","rowReadEnded","eachRow","row","values","BREAK_LINE","rowData","originalValue","fromExcelValue","isObjectNotEmpty","colIndex","getCell","parseSheetInCompatiableMode","obj","includeHeader","columnMapping","column","console","warn","col","fromexcel","slice","populateSheet","rows","LINKROW_NUMBER","font","color","argb","putBreakline","required","bold","dataValidations","affectedRowCount","optionsLabels","formulae","columnIndex","mod","remaining","floor","c","String","fromCharCode","charCodeAt","convertToXlsxColumnIndex","rowNumber","getDataValidationRange","r","dataValidation","type","allowBlank","showErrorMessage","rowIndex","rowValue","get","columnWidth","wch","arrayOfArray","width","maxlen","max","a2","getColumn","fitToColumn","mergeObject","source","isBrowser","Function","saveToFile","workbook","fileName","xlsx","writeBuffer","buffer","exportFileName","indexOf","blob","Blob","saveAs","writeFile","exportObjectsInSingleSheet","mergedObject","constructSheetColumnMetasFromObject","exportToExcel","sheets","exportObjectsInMultiSheet","fileMeta","Workbook","addWorksheet","parseObjectsFromExcel","file","ignoreWarning","consolidatedObject","removeEmptyFieldFromData","importObjects","compatiableMode","undefined","Promise","resolve","reject","readFile","reader","FileReader","onload","e","load","readAsArrayBuffer","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}